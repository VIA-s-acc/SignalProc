Документация для предоставленного кода:

memoize(func)
Мемоизирующий декоратор, добавляющий кэширование результатов вызовов функции.
 Мемоизация помогает оптимизировать функции, избегая повторных вычислений для одних и тех же входных аргументов.

Аргументы:

func (callable): Функция, которую нужно мемоизировать.
Возвращает:

callable: Обернутая функция, которая кэширует и возвращает результаты на основе входных аргументов.
make_immutable(obj)
Рекурсивно преобразует изменяемые объекты в неизменяемые типы.

wrapper(*args, **kwargs)
Оберточная функция для мемоизации.

Аргументы:

*args: Произвольный список аргументов.
**kwargs: Произвольный список именованных аргументов.
Возвращает:

Любое: Результат оригинальной функции для заданных аргументов.
class Signal
Класс для работы с сигналами.

Аргументы:

values (list): Список значений, представляющих сигнал.
start_index (int, опционально): Начальный индекс. По умолчанию 0.
end_index (int, опционально): Конечный индекс. По умолчанию None.
sig_name (str, опционально): Имя сигнала. По умолчанию None.
Методы:

downsample(factor): Уменьшает частоту сигнала на заданный коэффициент.
upsample(factor): Увеличивает частоту сигнала на заданный коэффициент.
convolve(kernel): Сворачивает сигнал с другим сигналом (ядром).
round(ndigits=0): Округляет значения сигнала до указанного числа знаков после запятой.
__add__(other): Складывает два объекта Signal покомпонентно.
__str__(): Преобразует объект Signal в строковое представление.
__len__(): Возвращает длину сигнала.
Дополнительные методы:

recursive_analysis(x, h0, h1, depth=0, max_depth=10, result=[]): Рекурсивный анализ сигнала.
recursive_synthesis(sig_list, f0, f1): Рекурсивный синтез сигналов из списка.
Synthesis(y0, y1, f0, f1): Рекурсивный синтез сигнала из двух других сигналов.
factorize_polynomial(Poly=None): Факторизует значения сигнала как полином.
generate_filters(HF): Генерирует фильтры H0, F0, H1, F1.
set_name(name): Устанавливает имя сигнала.